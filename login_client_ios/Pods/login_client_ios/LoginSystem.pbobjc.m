// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: login_system.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "LoginSystem.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - LSSLoginSystemRoot

@implementation LSSLoginSystemRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - LSSLoginSystemRoot_FileDescriptor

static GPBFileDescriptor *LSSLoginSystemRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"login_system"
                                                 objcPrefix:@"LSS"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - LSShelloRequest

@implementation LSShelloRequest

@dynamic helloClient;

typedef struct LSShelloRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *helloClient;
} LSShelloRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "helloClient",
        .dataTypeSpecific.className = NULL,
        .number = LSShelloRequest_FieldNumber_HelloClient,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LSShelloRequest__storage_, helloClient),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LSShelloRequest class]
                                     rootClass:[LSSLoginSystemRoot class]
                                          file:LSSLoginSystemRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LSShelloRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LSShelloResponse

@implementation LSShelloResponse

@dynamic helloServer;

typedef struct LSShelloResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *helloServer;
} LSShelloResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "helloServer",
        .dataTypeSpecific.className = NULL,
        .number = LSShelloResponse_FieldNumber_HelloServer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LSShelloResponse__storage_, helloServer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LSShelloResponse class]
                                     rootClass:[LSSLoginSystemRoot class]
                                          file:LSSLoginSystemRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LSShelloResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LSSregisterRequest

@implementation LSSregisterRequest

@dynamic h1;
@dynamic nickname;
@dynamic phoneNum;

typedef struct LSSregisterRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *h1;
  NSString *nickname;
  NSString *phoneNum;
} LSSregisterRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "h1",
        .dataTypeSpecific.className = NULL,
        .number = LSSregisterRequest_FieldNumber_H1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LSSregisterRequest__storage_, h1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = LSSregisterRequest_FieldNumber_Nickname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LSSregisterRequest__storage_, nickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phoneNum",
        .dataTypeSpecific.className = NULL,
        .number = LSSregisterRequest_FieldNumber_PhoneNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LSSregisterRequest__storage_, phoneNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LSSregisterRequest class]
                                     rootClass:[LSSLoginSystemRoot class]
                                          file:LSSLoginSystemRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LSSregisterRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LSSregisterResponse

@implementation LSSregisterResponse

@dynamic ret;
@dynamic msg;
@dynamic userId;

typedef struct LSSregisterResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  NSString *msg;
  NSString *userId;
} LSSregisterResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = LSSregisterResponse_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LSSregisterResponse__storage_, ret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = LSSregisterResponse_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LSSregisterResponse__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = LSSregisterResponse_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LSSregisterResponse__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LSSregisterResponse class]
                                     rootClass:[LSSLoginSystemRoot class]
                                          file:LSSLoginSystemRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LSSregisterResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LSSloginRequest

@implementation LSSloginRequest

@dynamic userId;
@dynamic data_p;

typedef struct LSSloginRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *data_p;
} LSSloginRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = LSSloginRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LSSloginRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = LSSloginRequest_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LSSloginRequest__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LSSloginRequest class]
                                     rootClass:[LSSLoginSystemRoot class]
                                          file:LSSLoginSystemRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LSSloginRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LSSloginResponse

@implementation LSSloginResponse

@dynamic ret;
@dynamic msg;
@dynamic st;

typedef struct LSSloginResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  NSString *msg;
  NSString *st;
} LSSloginResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = LSSloginResponse_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LSSloginResponse__storage_, ret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = LSSloginResponse_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LSSloginResponse__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "st",
        .dataTypeSpecific.className = NULL,
        .number = LSSloginResponse_FieldNumber_St,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LSSloginResponse__storage_, st),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LSSloginResponse class]
                                     rootClass:[LSSLoginSystemRoot class]
                                          file:LSSLoginSystemRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LSSloginResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LSSverifySTRequest

@implementation LSSverifySTRequest

@dynamic userId;
@dynamic st;

typedef struct LSSverifySTRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *st;
} LSSverifySTRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = LSSverifySTRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LSSverifySTRequest__storage_, userId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "st",
        .dataTypeSpecific.className = NULL,
        .number = LSSverifySTRequest_FieldNumber_St,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LSSverifySTRequest__storage_, st),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LSSverifySTRequest class]
                                     rootClass:[LSSLoginSystemRoot class]
                                          file:LSSLoginSystemRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LSSverifySTRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LSSverifySTResponse

@implementation LSSverifySTResponse

@dynamic ret;
@dynamic msg;

typedef struct LSSverifySTResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  NSString *msg;
} LSSverifySTResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = LSSverifySTResponse_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LSSverifySTResponse__storage_, ret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = LSSverifySTResponse_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LSSverifySTResponse__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LSSverifySTResponse class]
                                     rootClass:[LSSLoginSystemRoot class]
                                          file:LSSLoginSystemRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LSSverifySTResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
